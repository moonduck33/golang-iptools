package main

import (
	"bufio"
	"fmt"
	"net"
	"os"
	"strings"
	"sync"
)

func main() {
	fmt.Print("Enter domain list file: ")
	var file string
	fmt.Scanln(&file)

	domains, err := readDomains(file)
	if err != nil {
		fmt.Println("Error reading file:", err)
		return
	}

	fmt.Print("Thread count (e.g. 100-500): ")
	var threadCount int
	fmt.Scanln(&threadCount)
	if threadCount < 1 {
		threadCount = 100
	}

	// Load existing IPs to avoid duplicates
	existing := loadIPs("ips.txt")
	ipChan := make(chan string, threadCount*2)
	var resultLock sync.Mutex
	var results []string

	var wg sync.WaitGroup

	// Worker pool
	for i := 0; i < threadCount; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for domain := range ipChan {
				ip := resolve(domain)
				if ip == "" {
					continue
				}
				resultLock.Lock()
				if _, ok := existing[ip]; !ok {
					existing[ip] = struct{}{}
					results = append(results, ip)
				}
				resultLock.Unlock()
			}
		}()
	}

	for _, d := range domains {
		ipChan <- d
	}
	close(ipChan)
	wg.Wait()

	// Final write (batch)
	writeIPs("ips.txt", results)
	fmt.Printf("Done. %d new IPs written.\n", len(results))
}

func readDomains(path string) ([]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var list []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		line = strings.TrimPrefix(line, "http://")
		line = strings.TrimPrefix(line, "https://")
		if line != "" {
			list = append(list, line)
		}
	}
	return list, scanner.Err()
}

func loadIPs(path string) map[string]struct{} {
	m := make(map[string]struct{})
	file, err := os.Open(path)
	if err != nil {
		return m
	}
	defer file.Close()
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		ip := strings.TrimSpace(scanner.Text())
		if ip != "" {
			m[ip] = struct{}{}
		}
	}
	return m
}

func writeIPs(path string, ips []string) {
	if len(ips) == 0 {
		return
	}
	file, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		fmt.Println("Write error:", err)
		return
	}
	defer file.Close()

	for _, ip := range ips {
		file.WriteString(ip + "\n")
	}
}

func resolve(domain string) string {
	ips, err := net.LookupIP(domain)
	if err != nil || len(ips) == 0 {
		return ""
	}
	for _, ip := range ips {
		if ip.To4() != nil {
			return ip.String()
		}
	}
	return ""
}
